<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">

  <!--
    turf.js requires script-src: unsafe-eval https://github.com/Turfjs/turf/issues/1903
    mapboxgl requires several blob sources, documented at https://docs.mapbox.com/mapbox-gl-js/api/#csp-directives
  -->
  <meta http-equiv=content-security-policy
    content="default-src 'self' blob: data: ;
             child-src 'self' blob: https://*.auth0.com ;
             connect-src 'self' blob: data:
                https://*.auth0.com/
                https://sts.amazonaws.com https://*.s3.amazonaws.com
                https://api.mapbox.com https://events.mapbox.com https://*.tiles.mapbox.com ;
             frame-src 'self' https://*.auth0.com/ ;
             script-src 'self' 'unsafe-inline' 'unsafe-eval' blob:
                https://cdn.auth0.com/
                https://sdk.amazonaws.com/
                https://api.mapbox.com ;
             style-src 'self' 'unsafe-inline' https://api.mapbox.com ;
             ">
  
  <title>Test Tiles</title>
  <meta name="author" content="">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.auth0.com/js/auth0-spa-js/1.9/auth0-spa-js.production.js"></script>
  <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1.12.min.js"></script>
  <script src="js/auth.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.css" rel="stylesheet" />
  
  <script src="js/d3.min.js"></script>
  <script src="js/turf.min.js"></script>
  <link href="css/style.css" rel="stylesheet">
</head>

<body aria-busy="true">
    <div id="spinnerContainer" class="spinContainer">
        <div class="loading-spinner"></div>
    </div>
    
    <div class="container">
        <div id="topBar" class="topBar">
            <button id="logout" class="organization">Log Out</button>
            <button id="organization" class="organization"></button>
        </div><div id="bar2" class="bar2"></div>
        <div id="selectedFields" class="fieldBox">
        </div>
        <div id="mapContainer" class="mapContainer">
            <div id="map" class="map">
                <p class='instructions'>Click a field on the map to select it. When done, <button class="continue">continue</button> to model selection.</p>
                <div id='tiles' class='tiles'></div>
                <button class='layerButton stepClassed' onclick='toggleLayer(this)'>Layer visibility</button>
            </div>
        </div>
        <div id="dataContainer" class="dataContainer">
            <p>Choose datasets to use</p>
            <div id="leftMenu" class="dataMenu"></div>
            <div id="rightMenu" class="infoMenu">
                <p class='infoP'></p>
            </div>
        </div>
        <div id="modelContainer" class="modelContainer">
            <img id="testImage">
            <canvas id="testCanvas"></canvas>
            <canvas id="clipCanvas"></canvas>
            <div id="webglContainer" class="webglContainer">
                <canvas id="webglCanvas" style="display:block;"></canvas>
                <p class="barTitle">Napp ranges from 0 to 250 kg/ha</p>
                <canvas id="colorCanvas"></canvas>
                <svg id="eonrSlider" class="slider" width="250" height="40"></svg>
                <svg id="mSlider" class="slider" width="250" height="40"></svg>
                <svg id="sithreshSlider" class="slider" width="250" height="40"></svg>
            </div>
            
        </div>
        
    </div>
</body>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;

    void main() {
        //convert from pixels to 0.0 to 1.0
        vec2 zeroToOne = a_position / u_resolution;

        //convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne *2.0;

        //convert from 0->2 to -1->1 (clipspace)
        vec2 clipSpace = zeroToTwo - 1.0;

        //pass texCoord to fragment
        v_texCoord = a_texCoord;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;

    //texture
    uniform sampler2D u_image0;
    uniform sampler2D u_image1;

    //passed from vertex
    varying vec2 v_texCoord;

    uniform float eonr;
    uniform float m;
    uniform float sithresh;

    void main() {
        //look up color from texture
        vec4 color = texture2D(u_image0, v_texCoord);
        float napp = eonr * sqrt((1.0-color.x)/((1.0-sithresh)*(1.0+0.1*exp(m*(sithresh-color.x)))));
        vec4 outcolor = texture2D(u_image1, vec2(min(1.0,napp/250.0),0.0));
        gl_FragColor = vec4(outcolor.x, outcolor.y, outcolor.z, color.w);
    }
</script>

<script>

//define user data
function User() {
    this.organization = null;
    this.fields = [];
}

function modelVars() {
    this.eonr = 130.0;
    this.m = 0;
    this.sithresh = 0.7;
}

function pageState() {
    this.tab = 'FieldManagement'
    this.datasets = [
        {'dataset':'NAIP',
        'selected':0,
        'infoText':'Information about NAIP'},
        {'dataset':'SENTINEL',
        'selected':0,
        'infoText':'Information about SENTINEL'},
        {'dataset':'OTHER1',
        'selected':0,
        'infoText':'Information about OTHER1'},
        {'dataset':'OTHER2',
        'selected':0,
        'infoText':'Information about OTHER2'}
    ],
    this.mouseoverField = null;
    this.iLoad = 1;
    this.map = null;
}

var layers = [
    'userFields',
    'outline',
    'polys'
]

async function checkExists(folder) {
    let config = await (await fetch('/config.json')).json();
    let auth = await authentication;
    let home = new AWS.S3({params: {Bucket: config.aws.homeBucket} });
    let userId = (await auth.auth0.getIdTokenClaims()).sub;
    console.log(userId);

    home.config.credentials = auth.awsCredentials;
    //home.listObjects({Prefix: userId+'/'}, console.log)
    home.headObject({Key:userId+"/"+folder}, function(err, data) {
        if (err && err.code === "NotFound" ) {
            console.log("code", err.code);
        };
    })
}

//checkExists("fields");

function toggleLayer(el) {
    for (let i=0; i<layers.length;i++) {
        var visibility = page.map.getLayoutProperty(layers[i], 'visibility');
        if (visibility === 'visible') {
        page.map.setLayoutProperty(layers[i], 'visibility', 'none');
        d3.select(el).classed('stepClassed',false);
        } else {
        page.map.setLayoutProperty(layers[i], 'visibility', 'visible');
        d3.select(el).classed('stepClassed',true);
        }
    }
}

user = new User();
page = new pageState();
modelvars = new modelVars();

function Slider(id, field, domain) {
    var self=this;
    this.margin = {right:25, left:25};
    this.selection = d3.select("#"+id);
    this.selection.append("text")
    .attr("x",2)
    .attr("y",12)
    .text(field);
    this.hue = function(h) {
        modelvars[field] = h;
        self.handle.attr("cx", self.x(h));
        render(document.getElementById('clipCanvas'));
    };
    this.x = d3.scaleLinear()
        .domain(domain)
        .range([0, +self.selection.attr("width")-self.margin.right - self.margin.left])
        .clamp(true);
    this.slider = self.selection.append("g")
    .attr("class","slider")
    .attr("transform", "translate(" + self.margin.left + "," + self.selection.attr("height") / 2 + ")");
    this.slider.append("line")
    .attr("class", "track")
    .attr("x1", self.x.range()[0])
    .attr("x2", self.x.range()[1])
    .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-inset")
    .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-overlay")
    .call(d3.drag()
        .on("start.interrupt", function() { self.slider.interrupt(); })
        .on("start drag", function() { self.hue(self.x.invert(d3.event.x)); }));
    this.slider.insert("g", ".track-overlay")
    .attr("class", "ticks")
    .attr("transform", "translate(0," + 18 + ")")
    .selectAll("text")
    .data(self.x.ticks(5))
    .enter().append("text")
    .attr("x", self.x)
    .attr("text-anchor", "middle")
    .text(function(d) { return Math.round(d*100)/100; });
    this.handle = self.slider.insert("circle", ".track-overlay")
    .attr("class","handle")
    .attr("r",9)
    .attr("cx", self.x(modelvars[field]));
}

eonrslider = new Slider("eonrSlider","eonr",[0,250]);
mslider = new Slider("mSlider", "m", [0,50]);
sithreshslider = new Slider("sithreshSlider","sithresh",[0,1]);

var colorCanvas = document.getElementById("colorCanvas");
colorCanvas.width = 200;
colorCanvas.height=25;
var colorctx = colorCanvas.getContext('2d');
var grdt=colorctx.createLinearGradient(0,0,200,25);
var stops = [0, 0.25, 0.5, 0.75, 1.0];

for (let i = 0; i<stops.length; i++) {
    grdt.addColorStop(stops[i],d3.interpolatePlasma(stops[i]));
}

colorctx.fillStyle = grdt;
colorctx.fillRect(0,0,200,25);

function loadView(view) {
    console.log(view);
    d3.select('#'+page.tab).classed('stepClassed', false);
    d3.select('#'+view).classed('stepClassed', true);
    page.tab = view;

    if (view == 'FieldManagement') {
        loadFieldManagement();
    }
    if (view == 'DataSelection') {
        loadDataSelection();
    }

    if (view == 'ModelSelection') {
        loadModelSelection();
    }

}

function hideAll() {
    d3.select("#mapContainer").style('display','none');
    d3.select("#dataContainer").style('display','none');
    d3.select("#modelContainer").style('display','none');
}

function loadDataSelection() {
    hideAll();
    d3.select("#dataContainer").style('display','inline-block');
    var datasets = d3.select('#leftMenu').selectAll('div').data(page.datasets);
    
    datasets.enter().append('div')
        .attr('class','dataOption')
        .text(function(d) {
            return d['dataset'];
        })
        .on('click', function(d) {
            if (d['selected']==0) {
                //transition: background-color 0.25s;
                d['selected']=1;
                d3.select(this).classed('selected',true);
            } else {
                d['selected']=0;
                d3.select(this).classed('selected',false);
            }
           
            d3.select('.infoP').text(d['infoText']);
        })
    datasets.exit().remove();
}

//function to return blank geojson, which is helpful to initialize 
//layers that will be updated with user input
function blank() {
    return {
        type:"FeatureCollection",
        features:[]
    };
};

function getUniqueFeatures(array) {
    var existingFeatureKeys = {};
    // Because features come from tiled vector data, feature geometries may be split
    // or duplicated across tile boundaries and, as a result, features may appear
    // multiple times in query results.
    var uniqueFeatures = array.filter(function(el) {
    if (existingFeatureKeys[el.id]) {
    return false;
    } else {
    existingFeatureKeys[el.id] = true;
    return true;
    }
    });
    
    return uniqueFeatures;
}

function setColor() {
    if (loaded == 1) {
      
        var features = page.map.queryRenderedFeatures({ layers: ['polys'] });
        //console.log(features);
        for (let i = 0; i<features.length; i++) {
            page.map.setFeatureState({
                source:'ia',
                sourceLayer:'ia',
                id: features[i]['id']
                }, {
                'color':'#fff'
                }
            )
        }
    }
   
}

function range(start, stop, step) {
    if (typeof stop == 'undefined') {
        // one param defined
        stop = start;
        start = 0;
    }

    if (typeof step == 'undefined') {
        step = 1;
    }

    if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {
        return [];
    }

    var result = [];
    for (var i = start; step > 0 ? i < stop : i > stop; i += step) {
        result.push(i);
    }

    return result;
};

function loadModelSelection() {
    hideAll();
    d3.select("#modelContainer").style('display','inline-block');
}

function tile(lon, lat, n) {
    const convRad = Math.PI/180.0;
    let xtile = n * ((lon + 180) / 360);
    let ytile = n * (1 - (Math.log(Math.tan(lat*convRad) + (1/Math.cos(lat*convRad))) / Math.PI)) / 2;
    
    return [xtile, ytile];
}

function pixel(lon, lat) {
    const zoom = 14;
    const n = Math.pow(2,zoom);
    const convRad = Math.PI/180.0;
    const tileSize = 256;
    let xpixel = Math.floor(tileSize * n * ((lon + 180) / 360));
    let ypixel = Math.floor(tileSize * n * (1 - (Math.log(Math.tan(lat*convRad) + (1/Math.cos(lat*convRad))) / Math.PI)) / 2);
    
    return [xpixel, ypixel];
}

function returnTiles(bbox) {
    const zoom = 14;
    const n = Math.pow(2,zoom);

    let tilesw = tile(bbox[0], bbox[1], n);
    let tilene = tile(bbox[2], bbox[3], n);

    return [tilesw, tilene];
}

function lonlat(xtile, ytile) {
    const zoom = 14;
    const n = Math.pow(2,zoom);
    let lon_deg = xtile / n * 360.0 - 180.0;
    let lat_rad = Math.atan(Math.sinh(Math.PI*(1-2 * ytile / n)));
    let lat_deg = lat_rad * 180 / Math.PI;
    return [lon_deg, lat_deg];
}

function encode(data)
{
    var str = data.reduce(function(a,b){ return a+String.fromCharCode(b) },'');
    return btoa(str).replace(/.{76}(?=.)/g,'$&\n');
}

function createShader(gl, type, source) {
    let shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return shader;
    }

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
        return program;
    }

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}

let webglCanvas = document.getElementById('webglCanvas');
let gl = webglCanvas.getContext("webgl");
if (!gl) {
    console.log("initialization of webgl was bad");
}


//Much of the webgl related code is from webglfundamentals, created by
//Gregg Tavares
var vertexShaderSource = document.getElementById('vertex-shader').text;
var fragmentShaderSource = document.getElementById('fragment-shader').text;

//create shaders
var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

var program = createProgram(gl, vertexShader, fragmentShader);

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2,
  ]), gl.STATIC_DRAW);
}

function render(canvas) {
    var positionLocation = gl.getAttribLocation(program, "a_position");
    var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

    var positionBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    setRectangle(gl, 0, 0, canvas.width, canvas.height);

    //provide texture coordinates for the rectangle
    var texcoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,
        0.0, 1.0,
        1.0, 0.0,
        1.0, 1.0,
    ]), gl.STATIC_DRAW);
    var canvases = [canvas, document.getElementById("colorCanvas")]
    var textures = []
    for (var ii=0; ii<2; ii++) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // Set the parameters so we can render any size image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvases[ii]);
        textures.push(texture);
    }
    

    var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    let width = gl.canvas.clientWidth;
    let height = gl.canvas.clientHeight;
    //console.log("client", width, height);
    //if (gl.canvas.width != width || gl.canvas.height != height) {
    //    gl.canvas.width = width;
    //    gl.canvas.height = height;
    //}
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(program);

    gl.enableVertexAttribArray(positionLocation);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    var size = 2;
    var type = gl.FLOAT;
    var normalize = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);

    gl.enableVertexAttribArray(texcoordLocation);

    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

    var size = 2;
    var type = gl.FLOAT;
    var normalize = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);

    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

    var eonrLocation = gl.getUniformLocation(program, "eonr");
    var mLocation = gl.getUniformLocation(program,"m");
    var sithreshLocation = gl.getUniformLocation(program,"sithresh");

    gl.uniform1f(eonrLocation, modelvars.eonr);
    gl.uniform1f(mLocation, modelvars.m);
    gl.uniform1f(sithreshLocation, modelvars.sithresh);

    //image location
    var u_image0Location = gl.getUniformLocation(program, "u_image0");
    var u_image1Location = gl.getUniformLocation(program, "u_image1");
    gl.uniform1i(u_image0Location, 0);
    gl.uniform1i(u_image1Location, 1);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textures[0]);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, textures[1]);

    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);



}

function canvasWork(imageArray, numx, numy, testField, pixelTL) {
    console.log("inside canvas work");
    console.log(testField);
    const res = 256;
    let imgHeight = res*numy;
    let imgWidth = res*numx;
    
    let canvas = document.getElementById('testCanvas');
    canvas.width = imgWidth;
    canvas.height = imgHeight;
    let ctx = canvas.getContext('2d');
    let clipCanvas = document.getElementById('clipCanvas');
    clipCanvas.width = imgWidth;
    clipCanvas.height = imgHeight;
    //let ctx = canvas.getContext('2d');
    let ctxclip = clipCanvas.getContext('2d');
    for (let i=0; i<imageArray.length; i++) {
        console.log(i,(i%numx)*res,Math.floor(i/numx)*res);
        ctx.drawImage(imageArray[i], (i%numx)*res, Math.floor(i/numx)*res, res, res);
    }
    
    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    let fieldCoords; 
    ctx.strokeStyle = "#31eefd";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctxclip.strokeStyle = "#ff0000";
    ctxclip.lineWidth = 2;
    ctxclip.beginPath();
    fieldCoordsArray = testField.geometry.coordinates;
    if (testField.geometry.type=="Polygon" && fieldCoordsArray[0].length == 2) {
        console.log("first");
        //fieldCoords = testField.geometry.coordinates[0];
        fieldCoords = fieldCoordsArray;
        for (let i = 0; i < fieldCoords.length; i++) {
        let thisPixel = pixel(fieldCoords[i][0],fieldCoords[i][1]);
        
        if (i==0) {
            ctx.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            ctxclip.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            //ctx.moveTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
        }
        else {
            ctx.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            ctxclip.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            //ctx.lineTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
        } 
        }
        ctx.stroke();
    }
    else if (testField.geometry.type=="Polygon" && fieldCoordsArray[0].length > 2) {
        console.log("third");
        for (let j=0; j<fieldCoordsArray.length; j++) {
        fieldCoords = fieldCoordsArray[j]; 
        for (let i = 0; i < fieldCoords.length; i++) {
        let thisPixel = pixel(fieldCoords[i][0],fieldCoords[i][1]);
        
        if (i==0) {
            ctx.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            ctxclip.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            //ctx.moveTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
        }
        else {
            ctx.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            ctxclip.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            //ctx.lineTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
        } 
        }
        ctx.stroke();
        }
    }
   else {
        console.log("second");
        for (let j=0; j<fieldCoordsArray[0].length; j++) {
        fieldCoords = fieldCoordsArray[0][j]; 
        for (let i = 0; i < fieldCoords.length; i++) {
        let thisPixel = pixel(fieldCoords[i][0],fieldCoords[i][1]);
        
        if (i==0) {
            ctx.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            ctxclip.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            //ctx.moveTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
        }
        else {
            ctx.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            ctxclip.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
            //ctx.lineTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
        } 
        }
        ctx.stroke();
        }
    }

    
    
    // //ctxclip.stroke();
    // fieldCoords = testField.geometry.coordinates[0][1];
    // for (let i = 0; i < fieldCoords.length; i++) {
    //     let thisPixel = pixel(fieldCoords[i][0],fieldCoords[i][1]);
        
    //     if (i==0) {
    //         ctx.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
    //         ctxclip.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
    //         //ctx.moveTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
    //     }
    //     else {
    //         ctx.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
    //         ctxclip.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
    //         //ctx.lineTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
    //     } 
    // }

    // ctx.stroke();
    //ctxclip.stroke();
    ctxclip.clip("evenodd");
    //ctxclip.drawImage(img,0,0);
    for (let i=0; i<imageArray.length; i++) {
        ctxclip.drawImage(imageArray[i], (i%numx)*res, Math.floor(i/numx)*res, res, res);
    }
    let clipimageData = ctxclip.getImageData(0, 0, clipCanvas.width, clipCanvas.height);
    
    
    webglCanvas.width = imgWidth;
    webglCanvas.height = imgHeight;
    
    render(clipCanvas);
}


async function loadFieldData(testField) {
    let  auth = await authentication;
    //let testField = data.features[data.features.length - 1];
    let testBbox = turf.bbox(testField);
    
    let cornerTiles = returnTiles(testBbox);
    
    console.log("corner tiles", cornerTiles);
    
    let minx = Math.floor(cornerTiles[0][0]);
    let maxx = Math.floor(cornerTiles[1][0]);
    let miny = Math.floor(cornerTiles[1][1]);
    let maxy = Math.floor(cornerTiles[0][1]);

    let rangex = range(0, maxx-minx+1, 1);
    let rangey = range(0, maxy-miny+1, 1);

    console.log(rangex, rangey);

    let tilex = Math.floor(cornerTiles[0][0]);
    let tiley = Math.floor(cornerTiles[1][1]);
    let top = tiley;
    let left = tilex;
    let topLeft = lonlat(left,top);
    
    let pixelTL = pixel(topLeft[0], topLeft[1]);
    
    let tileBucket = new AWS.S3({params: {Bucket: "pagaf.nltgis.com"} });
    tileBucket.config.credentials = auth.awsCredentials;

    let imageUrls = [];
    for (let j=0; j<rangey.length; j++) {
        for (let i=0; i<rangex.length; i++) {
            console.log('r/corn/si/current/14/'+(minx+rangex[i])+'/'+(miny+rangey[j])+'.png');
            imageUrls.push('r/corn/si/current/14/'+(minx+rangex[i])+'/'+(miny+rangey[j])+'.png');
        }
    }

    let imagesLoaded = 0;
    let totalImages = imageUrls.length;
    let imageArray = new Array(totalImages);
    for (let i=0; i<imageUrls.length; i++) {
        tileBucket.getObject({Key:imageUrls[i]}, function (err, data) {
            
            let encoded = encode(data.Body);
            let thisImage = document.createElement('img');
            thisImage.id = "image"
            imageArray[i]=thisImage;
            imageArray[i].onload=function() {
                console.log("i",i);
                console.log(imageUrls[i])
                console.log(this.width, this.height);
            imagesLoaded += 1;
            console.log(imagesLoaded);
            if (imagesLoaded == totalImages) {
                console.log("all loaded");
                canvasWork(imageArray, rangex.length, rangey.length, testField, pixelTL);
            }
            }
            console.log(i,imageUrls[i]);
            imageArray[i].src = 'data:image/png;base64,' + encoded;
        })
        
    }
}

async function loadFieldManagement() {
    hideAll();
    d3.select("#mapContainer").style('display', 'inline-block');
    let config = await (await fetch('/config.json')).json();
    let  auth = await authentication;
    let home = new AWS.S3({params: {Bucket: config.aws.homeBucket} });
    let userId = (await auth.auth0.getIdTokenClaims()).sub;
    d3.json('data/userFields.geojson', function(error, data){
        if (error) console.log(error);
       
        page.map.getSource('userFields').setData(data);
        let bbox = turf.bbox(data);
       
        page.box = [[bbox[0],bbox[1]],[bbox[2],bbox[3]]];

        
        
        user.fields = data;
        // var fieldDivs = d3.select('#selectedFields').selectAll('div').data(user.fields.features);
        
        //         fieldDivs.enter().append('div')
        //             .attr('class', 'fieldDiv')
        //             .text(function(d) {
        //                 return d.properties.T_INDEX;
        //             })

        //             fieldDivs.exit().remove();

        var fieldDivs = d3.select('#selectedFields').selectAll("svg").data(user.fields.features);
        var fieldSvgs = fieldDivs.enter().append("svg")
            .attr("class","fieldSvg")
            .attr("id", function(d) {
                console.log(d);
                return "id"+d.properties.T_INDEX;
            })
            .on("click", function(d) {
                console.log(d);
                if (page.tab=="ModelSelection") {
                    d3.select("#selectedFields").selectAll("svg").classed("svgSelected",false);
                    d3.select(this).classed("svgSelected",true);
                    loadFieldData(d);
                }
                else {
                    d3.select("#selectedFields").selectAll("svg").classed("svgSelected",false);
                }
                
            });
        var fieldGs = fieldSvgs
            .append("g");

        fieldSvgs.each(function(d) {
            let el = d3.select(this);
            let rect=el.node().getBoundingClientRect();
            let width = rect.width;
            let height = rect.height;
            let geojson = blank();
            geojson.features.push(d);
            let projection = d3.geoMercator().fitExtent([[5,5],[width-5, height-5]], geojson);
            let path = d3.geoPath().projection(projection);
            el.select("g").selectAll("path")
                .data(geojson.features)
                .enter()
                .append("path")
                .attr("d",path)
                .style("fill","none")
                .style("stroke-width",3);
        })
        
        //only zoom to field bounds on page load
        if (page.iLoad == 1) {
            page.map.fitBounds(page.box);
            page.iLoad = 0;
            var objDiv = document.getElementById("selectedFields");
            objDiv.scrollTop = objDiv.scrollHeight;
        } 

        
        
        //tileBucket.getObject({Key:'r/corn/si/current/14/'+tilex+'/'+tiley+'.png'}, function (err, data) {
            //if (err) console.log(err, err.stack);
            //else console.log(data);
            //let encoded = encode(data.Body);
            //let img = document.getElementById("testImage")
            //img.src = 'data:image/png;base64,' + encoded;
            //img.onload = function() {
                
            //}
            
        //});
        //tileBucket.listObjects({Prefix:'r/corn/si/current/'}, console.log);
    })
}

var steps = [
    {'title':'Field Management',
    'id': 'FieldManagement'},
    //{'title':'Data Selection',
    //'id':'DataSelection'},
    {'title':'Model Selection',
    'id':'ModelSelection'}
]

var bar2Divs = d3.select('#bar2').selectAll('button').data(steps).enter().append('button').attr('class', 'step').text(function(d){
    return d['title'];
})
.attr('id', function(d) { return d['id'];})
.on('click', function(d) {
    loadView(d['id']);
});

bar2Divs.each(function(d) {
   
    if (d['id']==page.tab) {
        console.log('yes',this)
        d3.select(this).classed('stepClassed',true);
    } else {
        d3.select(this).classed('stepClassed',false);
    }
});

var fields = [];
var loaded = 0;

mapboxgl.accessToken = 'pk.eyJ1IjoiY2Vuc3VzcGFnYWYiLCJhIjoiY2tid2FjZmxxMDZoczJycGtxNmthamNrYyJ9.g9IGWfD-Nz9waQzHT5klkg'
 //initialize map
console.log('initializing map');
async function initializeMap() {
    await authentication;
    var map = new mapboxgl.Map({
            container: 'tiles', // container id
            style: 'mapbox://styles/censuspagaf/ckbwcdt9h0k3e1iplxvtr36vx',
            center: [-93.5, 37.5], // starting position
            zoom: 3, // starting zoom
            maxZoom:15
        });
    page.map = map;
    
    map.on('load', function() {
    //wait til last moment to resize map
   
    map.addSource('ia', {
            id:'fields',
            type:'vector',
            "metadata": {
            "mapbox:autocomposite": true
            },
            'maxzoom':11,
            tiles:[window.location.origin + "/data/ia/{z}/{x}/{y}.pbf"]
        });

    map.addSource('outlineSource', {
                    'type':'geojson',
                    'data':blank()
                })
    map.addSource('userFields', {
        'type':'geojson',
        'data':blank()
    })
    map.addLayer({
        'id':'polys',
        'maxzoom': 16,
        'type':'fill',
        'source':'ia',
        'source-layer':'ia',
        'layout': {
            'visibility':'visible'
        },
        //  'paint': {
        //      'fill-color': [
        //          'interpolate',
        //          ['linear'],
        //          ['get','CALCACRES'],
        //          0,
        //          '#9EFFA0',
        //          500,
        //          '#00610F'
        //      ],
        //      'fill-opacity':0.8
        //  }
        'paint':{
            'fill-outline-color':'#fff',
            'fill-color':'rgba(0,0,0,0)'
        }
    },"aerialway")
    

    map.addLayer({
        'id':'userFields',
        'type':'fill',
        'source':'userFields',
        'layout': {
            'visibility':'visible'
        },
        'paint':{
            'fill-color':'#31eefd',
            'fill-opacity':0.8,
            'fill-outline-color':'#000'
        }
    },'aerialway')

    map.addLayer({
        'id':'outline',
        'type':'fill',
        'source':'outlineSource',
        'layout': {
            'visibility':'visible'
        },
        'paint':{
        'fill-color':'#ffffff'
        }
    },'aerialway')
    
    loadView('FieldManagement');
    document.body.removeAttribute('aria-busy')
    map.resize();
    function sourceCallback() {
                    
        if (map.getSource('ia') && map.isSourceLoaded('ia')) {
            loaded = 1;
            //setColor();
            map.off('sourcedata',sourceCallback);
        }
    }
    map.on('mousemove', 'polys', function(e) {
        //console.log(e.features);
        //var geom = blank();
        //geom['features'] = [e.features[0].geometry];
        //map.getSource('outlineSource').setData(e.features[0].geometry);
        var toMatch = e.features[0].properties['T_INDEX'];
        
        var latLon = e.lngLat.wrap();
        var lat = latLon.lat;
        var lon = latLon.lng;
        var sw = [
            lon-0.005,
            lat-0.005
        ]
        var ne = [
            lon+0.005,
            lat+0.005
        ]
            
        
        //console.log(e.point.x, e.point.y);
        //console.log(map.project(sw), map.project(ne));
        var swProject = map.project(sw);
        var neProject = map.project(ne);
        var features = map.queryRenderedFeatures([swProject,neProject], {
            layers:['polys']
        });

        toDissolve = blank();
        for (let i=0; i<features.length; i++) {
            
            if (features[i]['properties']['T_INDEX'] == toMatch) {
                toDissolve.features.push({
                    type:'Feature',
                    geometry:features[i].geometry,
                    properties:{'T_INDEX':toMatch}
                })
            }
        }

        fullGeom = turf.dissolve(toDissolve, {propertyName:'T_INDEX'});
        map.getSource('outlineSource').setData(fullGeom);
        page.mouseoverField = fullGeom;

    });
    map.on('mouseenter','polys',function(e) {
                    map.getCanvas().style.cursor = 'pointer';
                })
                map.on('mouseleave', 'polys', function(e) {
                     map.getCanvas().style.cursor = '';
                 })
                 map.on('mouseenter','outline',function(e) {
                    map.getCanvas().style.cursor = 'pointer';
                })
                map.on('mouseleave', 'outline', function(e) {
                     map.getCanvas().style.cursor = '';
                     map.getSource('outlineSource').setData(blank());
                 })
                
    map.on('sourcedata', sourceCallback);
    map.on('click', function(e) {
                
                var layers = map.queryRenderedFeatures(e.point);
                
                //only fire event for top layer
                // for (var i = 0; i<layers.length; i++) {
                //     if (layers[i]['layer']['id'] == 'polys') {
                //         user.fields.features.push(
                //             {
                //             type:'Feature',
                //             properties:{
                //                 T_INDEX:layers[i]['properties']['T_INDEX']
                //             },
                //             geometry:layers[i].geometry
                //             }
                //             )
                //         console.log(fields);
                //     }
                // }

                for (var i = 0; i<layers.length; i++) {
                     if (layers[i]['layer']['id'] == 'polys' && page.mouseoverField != null) {
                         var beforeSize = user.fields.features.length;
                         var filtered = user.fields.features.filter(function(d) {
                             return d.properties['T_INDEX'] != layers[i].properties['T_INDEX'];
                         })

                         var afterSize = filtered.length;
        
                         if (beforeSize != afterSize) {
                            user.fields.features = filtered;
                         }
                         else {
                            user.fields.features.push(page.mouseoverField.features[0]);
                         }  
                     }
                }

                // var features = map.queryRenderedFeatures({ layers: ['polys'] });
                
                // //console.log(features);
                // var lastAdded = user.fields.features[user.fields.features.length-1].properties['T_INDEX'];
                // toDissolve = blank();
                // for (let i=0; i<features.length; i++) {
                    
                //     if (features[i]['properties']['T_INDEX'] == lastAdded) {
                //         toDissolve.features.push({
                //             type:'Feature',
                //             geometry:features[i].geometry
                //         })
                //     }
                // }




            


                var fieldDivs = d3.select('#selectedFields').selectAll('svg').data(user.fields.features);
                fieldDivs.exit().remove();
                fieldDivs.each(function(d,i) {
                    //console.log(i,d.properties.T_INDEX);
                    let el = d3.select(this);
                    let rect=el.node().getBoundingClientRect();
                    let width = rect.width;
                    let height = rect.height;
                    let geojson = blank();
                    geojson.features.push(d);
                    let projection = d3.geoMercator().fitExtent([[5,5],[width-5, height-5]], geojson);
                    let path = d3.geoPath().projection(projection);
                    //no need to enter on existing
                    el.select("g").selectAll("path")
                        .data(geojson.features)
                        .attr("d",path)
                        .style("fill","none")
                        .style("stroke-width",3);
                })
                
                var fieldSvgs = fieldDivs.enter().append("svg")
                .attr("class","fieldSvg")
                .attr("id", function(d) {
                    return "id"+d.properties.T_INDEX;
                })
                .on("click", function(d) {
                console.log(d);
                if (page.tab=="ModelSelection") {
                    d3.select("#selectedFields").selectAll("svg").classed("svgSelected",false);
                    d3.select(this).classed("svgSelected",true);
                    loadFieldData(d);
                }
                else {
                    d3.select("#selectedFields").selectAll("svg").classed("svgSelected",false);
                }
                
            });
                var fieldGs = fieldSvgs
                    .append("g");
                    //on new elements, need to append "path"
                    fieldSvgs.each(function(d) {
                    let el = d3.select(this);
                    let rect=el.node().getBoundingClientRect();
                    let width = rect.width;
                    let height = rect.height;
                    let geojson = blank();
                    geojson.features.push(d);
                    let projection = d3.geoMercator().fitExtent([[5,5],[width-5, height-5]], geojson);
                    let path = d3.geoPath().projection(projection);
                    el.select("g").selectAll("path")
                        .data(geojson.features)
                        .enter()
                        .append("path")
                        .attr("d",path)
                        .style("fill","none")
                        .style("stroke-width",3);
                })

                
                var objDiv = document.getElementById("selectedFields");
                objDiv.scrollTop = objDiv.scrollHeight;
                

                

               

                
                
                // fieldDivs.enter().append('div')
                //     .attr('class', 'fieldDiv')
                //     .text(function(d) {
                //         return d.properties.T_INDEX;
                //     })
                var updated = blank();
                updated.features = user.fields.features;
                map.getSource('userFields').setData(updated);
            })
    //map.on('zoomend', function() {
    //    setColor();
        
         //if (features) {
         //var uniqueFeatures = getUniqueFeatures(features);
         //fields = uniqueFeatures;
         //console.log(uniqueFeatures);
        // // Populate features for the listing overlay.
        // renderListings(uniqueFeatures);
        
        // // Clear the input container
        // filterEl.value = '';
        
        // // Store the current features in sn `airports` variable to
        // // later use for filtering on `keyup`.
        // airports = uniqueFeatures;
        // }
    //);
    
})

}

initializeMap();

</script>