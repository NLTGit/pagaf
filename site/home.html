<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Test Tiles</title>
  <meta name="author" content="">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.auth0.com/js/auth0-spa-js/1.9/auth0-spa-js.production.js"></script>
  <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1.12.min.js"></script>
  <script src="js/auth.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.css" rel="stylesheet" />
  
  <script src="js/d3.min.js"></script>
  <script src="js/turf.min.js"></script>
  <link href="css/style.css" rel="stylesheet">
</head>

<body aria-busy=true>
    <div id="spinnerContainer" class="spinContainer">
        <div class="loading-spinner"></div>
    </div>
    
    <div class="container">
        <div id="topBar" class="topBar">
            <button id="logout" class="organization">Log Out</button>
            <button id="organization" class="organization"></button>
        </div><div id="bar2" class="bar2"></div>
        <div id="mapContainer" class="mapContainer">
            <div id="selectedFields" class="fieldBox">
                <p class='instructions'>Click a field on the map to select it</p>
            </div>
            <div id="map" class="map">
                <div id='tiles' class='tiles'></div>
                <button class='layerButton stepClassed' onclick='toggleLayer(this)'>Layer visibility</button>
            </div>
        </div>
        <div id="dataContainer" class="dataContainer">
            <p>Choose datasets to use</p>
            <div id="leftMenu" class="dataMenu"></div>
            <div id="rightMenu" class="infoMenu">
                <p class='infoP'></p>
            </div>
        </div>
        <div id="modelContainer" class="modelContainer">
            <img id="testImage">
            <canvas id="testCanvas"></canvas>
            <canvas id="clipCanvas"></canvas>
            <div id="webglContainer" class="webglContainer">
                <canvas id="webglCanvas" style="display:block;"></canvas>
                <p class="barTitle">Napp ranges from 0 to 250 kg/ha</p>
                <canvas id="colorCanvas"></canvas>
                <svg id="eonrSlider" class="slider" width="250" height="40"></svg>
                <svg id="mSlider" class="slider" width="250" height="40"></svg>
                <svg id="sithreshSlider" class="slider" width="250" height="40"></svg>
            </div>
            
        </div>
        
    </div>
</body>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;

    void main() {
        //convert from pixels to 0.0 to 1.0
        vec2 zeroToOne = a_position / u_resolution;

        //convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne *2.0;

        //convert from 0->2 to -1->1 (clipspace)
        vec2 clipSpace = zeroToTwo - 1.0;

        //pass texCoord to fragment
        v_texCoord = a_texCoord;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;

    //texture
    uniform sampler2D u_image0;
    uniform sampler2D u_image1;

    //passed from vertex
    varying vec2 v_texCoord;

    uniform float eonr;
    uniform float m;
    uniform float sithresh;

    void main() {
        //look up color from texture
        vec4 color = texture2D(u_image0, v_texCoord);
        float napp = eonr * sqrt((1.0-color.x)/((1.0-sithresh)*(1.0+0.1*exp(m*(sithresh-color.x)))));
        vec4 outcolor = texture2D(u_image1, vec2(min(1.0,napp/250.0),0.0));
        gl_FragColor = vec4(outcolor.x, outcolor.y, outcolor.z, color.w);
    }
</script>

<script>

//define user data
function User() {
    this.organization = null;
    this.fields = [];
}

function modelVars() {
    this.eonr = 130.0;
    this.m = 0;
    this.sithresh = 0.7;
}

function pageState() {
    this.tab = 'FieldManagement'
    this.datasets = [
        {'dataset':'NAIP',
        'selected':0,
        'infoText':'Information about NAIP'},
        {'dataset':'SENTINEL',
        'selected':0,
        'infoText':'Information about SENTINEL'},
        {'dataset':'OTHER1',
        'selected':0,
        'infoText':'Information about OTHER1'},
        {'dataset':'OTHER2',
        'selected':0,
        'infoText':'Information about OTHER2'}
    ],
    this.mouseoverField = null;
    this.iLoad = 1;
}

var layers = [
    'userFields',
    'outline',
    'polys'
]

function toggleLayer(el) {
    for (let i=0; i<layers.length;i++) {
        var visibility = map.getLayoutProperty(layers[i], 'visibility');
        if (visibility === 'visible') {
        map.setLayoutProperty(layers[i], 'visibility', 'none');
        d3.select(el).classed('stepClassed',false);
        } else {
        map.setLayoutProperty(layers[i], 'visibility', 'visible');
        d3.select(el).classed('stepClassed',true);
        }
    }
}

user = new User();
page = new pageState();
modelvars = new modelVars();

function Slider(id, field, domain) {
    var self=this;
    this.margin = {right:25, left:25};
    this.selection = d3.select("#"+id);
    this.selection.append("text")
    .attr("x",2)
    .attr("y",12)
    .text(field);
    this.hue = function(h) {
        modelvars[field] = h;
        self.handle.attr("cx", self.x(h));
        render(document.getElementById('clipCanvas'));
    };
    this.x = d3.scaleLinear()
        .domain(domain)
        .range([0, +self.selection.attr("width")-self.margin.right - self.margin.left])
        .clamp(true);
    this.slider = self.selection.append("g")
    .attr("class","slider")
    .attr("transform", "translate(" + self.margin.left + "," + self.selection.attr("height") / 2 + ")");
    this.slider.append("line")
    .attr("class", "track")
    .attr("x1", self.x.range()[0])
    .attr("x2", self.x.range()[1])
    .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-inset")
    .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
    .attr("class", "track-overlay")
    .call(d3.drag()
        .on("start.interrupt", function() { self.slider.interrupt(); })
        .on("start drag", function() { self.hue(self.x.invert(d3.event.x)); }));
    this.slider.insert("g", ".track-overlay")
    .attr("class", "ticks")
    .attr("transform", "translate(0," + 18 + ")")
    .selectAll("text")
    .data(self.x.ticks(5))
    .enter().append("text")
    .attr("x", self.x)
    .attr("text-anchor", "middle")
    .text(function(d) { return Math.round(d*100)/100; });
    this.handle = self.slider.insert("circle", ".track-overlay")
    .attr("class","handle")
    .attr("r",9)
    .attr("cx", self.x(modelvars[field]));
}

eonrslider = new Slider("eonrSlider","eonr",[0,250]);
mslider = new Slider("mSlider", "m", [0,50]);
sithreshslider = new Slider("sithreshSlider","sithresh",[0,1]);

// //create sliders
// var margin = {right:25,left:25};

// function hue(h) {
//     //console.log(h);
//   modelvars.eonr = h;
//   eonrHandle.attr("cx", xeonr(h));
//   //svgeonr.style("background-color", d3.hsl(h, 0.8, 0.8));
//   render(document.getElementById('clipCanvas'));
// }

// var svgeonr = d3.select("#eonrSlider");
// var xeonr = d3.scaleLinear()
//     .domain([0,250])
//     .range([0, +svgeonr.attr("width")-margin.right - margin.left])
//     .clamp(true);

// var eonrslider = svgeonr.append("g")
// .attr("class","slider")
// .attr("transform", "translate(" + margin.left + "," + svgeonr.attr("height") / 2 + ")");

// eonrslider.append("line")
// .attr("class", "track")
//     .attr("x1", xeonr.range()[0])
//     .attr("x2", xeonr.range()[1])
//   .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
//     .attr("class", "track-inset")
//   .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
//     .attr("class", "track-overlay")
//     .call(d3.drag()
//         .on("start.interrupt", function() { eonrslider.interrupt(); })
//         .on("start drag", function() { hue(xeonr.invert(d3.event.x)); }));
// //eonrslider.insert("g",".track-overlay")
// var eonrHandle = eonrslider.insert("circle", ".track-overlay")
// .attr("class","handle")
// .attr("r",9)
// .attr("cx", modelvars.eonr);


var colorCanvas = document.getElementById("colorCanvas");
colorCanvas.width = 200;
colorCanvas.height=25;
var colorctx = colorCanvas.getContext('2d');
var grdt=colorctx.createLinearGradient(0,0,200,25);
var stops = [0, 0.25, 0.5, 0.75, 1.0];

for (let i = 0; i<stops.length; i++) {
    grdt.addColorStop(stops[i],d3.interpolatePlasma(stops[i]));
}

colorctx.fillStyle = grdt;
colorctx.fillRect(0,0,200,25);

function loadView(view) {
    console.log(view);
    d3.select('#'+page.tab).classed('stepClassed', false);
    d3.select('#'+view).classed('stepClassed', true);
    page.tab = view;

    if (view == 'FieldManagement') {
        loadFieldManagement();
    }
    if (view == 'DataSelection') {
        loadDataSelection();
    }

    if (view == 'ModelSelection') {
        loadModelSelection();
    }

}

function hideAll() {
    d3.select("#mapContainer").style('display','none');
    d3.select("#dataContainer").style('display','none');
    d3.select("#modelContainer").style('display','none');
}

function loadDataSelection() {
    hideAll();
    d3.select("#dataContainer").style('display','inline-block');
    var datasets = d3.select('#leftMenu').selectAll('div').data(page.datasets);
    
    datasets.enter().append('div')
        .attr('class','dataOption')
        .text(function(d) {
            return d['dataset'];
        })
        .on('click', function(d) {
            if (d['selected']==0) {
                //transition: background-color 0.25s;
                d['selected']=1;
                d3.select(this).classed('selected',true);
            } else {
                d['selected']=0;
                d3.select(this).classed('selected',false);
            }
           
            d3.select('.infoP').text(d['infoText']);
        })
    datasets.exit().remove();
}

function loadModelSelection() {
    hideAll();
    d3.select("#modelContainer").style('display','inline-block');
}

function tile(lon, lat, n) {
    const convRad = Math.PI/180.0;
    let xtile = n * ((lon + 180) / 360);
    let ytile = n * (1 - (Math.log(Math.tan(lat*convRad) + (1/Math.cos(lat*convRad))) / Math.PI)) / 2;
    
    return [xtile, ytile];
}

function pixel(lon, lat) {
    const zoom = 14;
    const n = Math.pow(2,zoom);
    const convRad = Math.PI/180.0;
    const tileSize = 256;
    let xpixel = Math.floor(tileSize * n * ((lon + 180) / 360));
    let ypixel = Math.floor(tileSize * n * (1 - (Math.log(Math.tan(lat*convRad) + (1/Math.cos(lat*convRad))) / Math.PI)) / 2);
    
    return [xpixel, ypixel];
}

function returnTiles(bbox) {
    const zoom = 14;
    const n = Math.pow(2,zoom);

    let tilesw = tile(bbox[0], bbox[1], n);
    let tilene = tile(bbox[2], bbox[3], n);

    return [tilesw, tilene];
}

function lonlat(xtile, ytile) {
    const zoom = 14;
    const n = Math.pow(2,zoom);
    let lon_deg = xtile / n * 360.0 - 180.0;
    let lat_rad = Math.atan(Math.sinh(Math.PI*(1-2 * ytile / n)));
    let lat_deg = lat_rad * 180 / Math.PI;
    return [lon_deg, lat_deg];
}

function encode(data)
{
    var str = data.reduce(function(a,b){ return a+String.fromCharCode(b) },'');
    return btoa(str).replace(/.{76}(?=.)/g,'$&\n');
}

function createShader(gl, type, source) {
    let shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return shader;
    }

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
        return program;
    }

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}

let webglCanvas = document.getElementById('webglCanvas');
let gl = webglCanvas.getContext("webgl");
if (!gl) {
    console.log("initialization of webgl was bad");
}


//Much of the webgl related code is from webglfundamentals, created by
//Gregg Tavares
var vertexShaderSource = document.getElementById('vertex-shader').text;
var fragmentShaderSource = document.getElementById('fragment-shader').text;

//create shaders
var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

var program = createProgram(gl, vertexShader, fragmentShader);

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2,
  ]), gl.STATIC_DRAW);
}

function render(canvas) {
    var positionLocation = gl.getAttribLocation(program, "a_position");
    var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

    var positionBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    setRectangle(gl, 0, 0, canvas.width, canvas.height);

    //provide texture coordinates for the rectangle
    var texcoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,
        0.0, 1.0,
        1.0, 0.0,
        1.0, 1.0,
    ]), gl.STATIC_DRAW);
    var canvases = [canvas, document.getElementById("colorCanvas")]
    var textures = []
    for (var ii=0; ii<2; ii++) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // Set the parameters so we can render any size image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvases[ii]);
        textures.push(texture);
    }
    

    var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    let width = gl.canvas.clientWidth;
    let height = gl.canvas.clientHeight;
    //console.log("client", width, height);
    //if (gl.canvas.width != width || gl.canvas.height != height) {
    //    gl.canvas.width = width;
    //    gl.canvas.height = height;
    //}
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(program);

    gl.enableVertexAttribArray(positionLocation);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    var size = 2;
    var type = gl.FLOAT;
    var normalize = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);

    gl.enableVertexAttribArray(texcoordLocation);

    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

    var size = 2;
    var type = gl.FLOAT;
    var normalize = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);

    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

    var eonrLocation = gl.getUniformLocation(program, "eonr");
    var mLocation = gl.getUniformLocation(program,"m");
    var sithreshLocation = gl.getUniformLocation(program,"sithresh");

    gl.uniform1f(eonrLocation, modelvars.eonr);
    gl.uniform1f(mLocation, modelvars.m);
    gl.uniform1f(sithreshLocation, modelvars.sithresh);

    //image location
    var u_image0Location = gl.getUniformLocation(program, "u_image0");
    var u_image1Location = gl.getUniformLocation(program, "u_image1");
    gl.uniform1i(u_image0Location, 0);
    gl.uniform1i(u_image1Location, 1);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textures[0]);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, textures[1]);

    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);



}

async function loadFieldManagement() {
    let config = await (await fetch('/config.json')).json();
    let  auth = await authentication;
    let home = new AWS.S3({params: {Bucket: config.aws.homeBucket} });
    let userId = (await auth.auth0.getIdTokenClaims()).sub;
    d3.json('data/userFields.geojson', function(error, data){
        if (error) console.log(error);
        hideAll();
        d3.select("#mapContainer").style('display', 'inline-block');
        map.getSource('userFields').setData(data);
        let bbox = turf.bbox(data);
       
        page.box = [[bbox[0],bbox[1]],[bbox[2],bbox[3]]];

        //only zoom to field bounds on page load
        if (page.iLoad == 1) {
            map.fitBounds(page.box);
            page.iLoad = 0;
        } 
        
        user.fields = data;
        var fieldDivs = d3.select('#selectedFields').selectAll('div').data(user.fields.features);
        
                //fieldDivs.data(fields);
                //fieldDivs.exit().remove();
                fieldDivs.enter().append('div')
                    .attr('class', 'fieldDiv')
                    .text(function(d) {
                        return d.properties.T_INDEX;
                    })

                    fieldDivs.exit().remove();

        let testField = data.features[data.features.length - 1];
        let testBbox = turf.bbox(testField);
        
        let cornerTiles = returnTiles(testBbox);
        
        console.log(cornerTiles);
        
        let tilex = Math.floor(cornerTiles[0][0]);
        let tiley = Math.floor(cornerTiles[0][1]);
        let top = tiley;
        let left = tilex;
        let topLeft = lonlat(left,top);
       
        let pixelTL = pixel(topLeft[0], topLeft[1]);
      
        let tileBucket = new AWS.S3({params: {Bucket: "pagaf.nltgis.com"} });
        tileBucket.config.credentials = auth.awsCredentials;
        
        tileBucket.getObject({Key:'r/corn/si/current/14/'+tilex+'/'+tiley+'.png'}, function (err, data) {
            if (err) console.log(err, err.stack);
            else console.log(data);
            let encoded = encode(data.Body);
            let img = document.getElementById("testImage")
            img.src = 'data:image/png;base64,' + encoded;
            img.onload = function() {
                let imgHeight = img.height;
                let imgWidth = img.width;
               
                let canvas = document.getElementById('testCanvas');
                canvas.width = imgWidth;
                canvas.height = imgHeight;
                let ctx = canvas.getContext('2d');
                let clipCanvas = document.getElementById('clipCanvas');
                clipCanvas.width = imgWidth;
                clipCanvas.height = imgHeight;
                //let ctx = canvas.getContext('2d');
                let ctxclip = clipCanvas.getContext('2d');
                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
               
                let fieldCoords = testField.geometry.coordinates[0][0];
                ctx.strokeStyle = "#ff0000";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctxclip.strokeStyle = "#ff0000";
                ctxclip.lineWidth = 2;
                ctxclip.beginPath();

                for (let i = 0; i < fieldCoords.length; i++) {
                    let thisPixel = pixel(fieldCoords[i][0],fieldCoords[i][1]);
                    
                    if (i==0) {
                        ctx.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        ctxclip.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        //ctx.moveTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
                    }
                    else {
                        ctx.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        ctxclip.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        //ctx.lineTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
                    } 
                }
                ctx.stroke();
                //ctxclip.stroke();
                fieldCoords = testField.geometry.coordinates[0][1];
                for (let i = 0; i < fieldCoords.length; i++) {
                    let thisPixel = pixel(fieldCoords[i][0],fieldCoords[i][1]);
                   
                    if (i==0) {
                        ctx.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        ctxclip.moveTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        //ctx.moveTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
                    }
                    else {
                        ctx.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        ctxclip.lineTo(thisPixel[0]-pixelTL[0], thisPixel[1]-pixelTL[1]);
                        //ctx.lineTo(thisPixel[1]-pixelTL[1], thisPixel[0]-pixelTL[0]);
                    } 
                }

                ctx.stroke();
                //ctxclip.stroke();
                ctxclip.clip("evenodd");
                ctxclip.drawImage(img,0,0);
                let clipimageData = ctxclip.getImageData(0, 0, clipCanvas.width, clipCanvas.height);
               
               
                webglCanvas.width = imgWidth;
                webglCanvas.height = imgHeight;
               
                render(clipCanvas);
            }
            
        });
        //tileBucket.listObjects({Prefix:'r/corn/si/current/'}, console.log);
    })
}

var steps = [
    {'title':'Field Management',
    'id': 'FieldManagement'},
    //{'title':'Data Selection',
    //'id':'DataSelection'},
    {'title':'Model Selection',
    'id':'ModelSelection'}
]

var bar2Divs = d3.select('#bar2').selectAll('button').data(steps).enter().append('button').attr('class', 'step').text(function(d){
    return d['title'];
})
.attr('id', function(d) { return d['id'];})
.on('click', function(d) {
    loadView(d['id']);
});

bar2Divs.each(function(d) {
   
    if (d['id']==page.tab) {
        console.log('yes',this)
        d3.select(this).classed('stepClassed',true);
    } else {
        d3.select(this).classed('stepClassed',false);
    }
});

mapboxgl.accessToken = 'pk.eyJ1IjoiY2Vuc3VzcGFnYWYiLCJhIjoiY2tid2FjZmxxMDZoczJycGtxNmthamNrYyJ9.g9IGWfD-Nz9waQzHT5klkg'
 //initialize map
console.log('initializing map');
var map = new mapboxgl.Map({
            container: 'tiles', // container id
            style: 'mapbox://styles/censuspagaf/ckbwcdt9h0k3e1iplxvtr36vx',
            center: [-93.5, 37.5], // starting position
            zoom: 3, // starting zoom
            maxZoom:15
        });

var fields = [];
var loaded = 0;

//function to return blank geojson, which is helpful to initialize 
        //layers that will be updated with user input
        function blank() {
           return {
                type:"FeatureCollection",
                features:[]
            };
        };

function getUniqueFeatures(array) {
    var existingFeatureKeys = {};
    // Because features come from tiled vector data, feature geometries may be split
    // or duplicated across tile boundaries and, as a result, features may appear
    // multiple times in query results.
    var uniqueFeatures = array.filter(function(el) {
    if (existingFeatureKeys[el.id]) {
    return false;
    } else {
    existingFeatureKeys[el.id] = true;
    return true;
    }
    });
    
    return uniqueFeatures;
}

function setColor() {
    if (loaded == 1) {
      
        var features = map.queryRenderedFeatures({ layers: ['polys'] });
        //console.log(features);
        for (let i = 0; i<features.length; i++) {
            map.setFeatureState({
                source:'ia',
                sourceLayer:'ia',
                id: features[i]['id']
                }, {
                'color':'#fff'
                }
            )
        }
    }
   
}

map.on('load', function() {
    map.resize();
    map.addSource('ia', {
            id:'fields',
            type:'vector',
            "metadata": {
            "mapbox:autocomposite": true
            },
            'maxzoom':11,
            tiles:["https://s3.amazonaws.com/pagaf.nltgis.com/clutiles/{z}/{x}/{y}.pbf"]
        });

    map.addSource('outlineSource', {
                    'type':'geojson',
                    'data':blank()
                })
    map.addSource('userFields', {
        'type':'geojson',
        'data':blank()
    })
    map.addLayer({
        'id':'polys',
        'maxzoom': 16,
        'type':'fill',
        'source':'ia',
        'source-layer':'ia',
        'layout': {
            'visibility':'visible'
        },
        //  'paint': {
        //      'fill-color': [
        //          'interpolate',
        //          ['linear'],
        //          ['get','CALCACRES'],
        //          0,
        //          '#9EFFA0',
        //          500,
        //          '#00610F'
        //      ],
        //      'fill-opacity':0.8
        //  }
        'paint':{
            'fill-outline-color':'#fff',
            'fill-color':'rgba(0,0,0,0)'
        }
    },"aerialway")
    

    map.addLayer({
        'id':'userFields',
        'type':'fill',
        'source':'userFields',
        'layout': {
            'visibility':'visible'
        },
        'paint':{
            'fill-color':'#a80000',
            'fill-opacity':0.8,
            'fill-outline-color':'#000'
        }
    },'aerialway')

    map.addLayer({
        'id':'outline',
        'type':'fill',
        'source':'outlineSource',
        'layout': {
            'visibility':'visible'
        },
        'paint':{
        'fill-color':'#ffffff'
        }
    },'aerialway')
    
    loadView('FieldManagement');

    function sourceCallback() {
                    
        if (map.getSource('ia') && map.isSourceLoaded('ia')) {
            loaded = 1;
            //setColor();
            map.off('sourcedata',sourceCallback);
        }
    }
    map.on('mousemove', 'polys', function(e) {
        //console.log(e.features);
        //var geom = blank();
        //geom['features'] = [e.features[0].geometry];
        //map.getSource('outlineSource').setData(e.features[0].geometry);
        var toMatch = e.features[0].properties['T_INDEX'];
        
        var latLon = e.lngLat.wrap();
        var lat = latLon.lat;
        var lon = latLon.lng;
        var sw = [
            lon-0.005,
            lat-0.005
        ]
        var ne = [
            lon+0.005,
            lat+0.005
        ]
            
        
        //console.log(e.point.x, e.point.y);
        //console.log(map.project(sw), map.project(ne));
        var swProject = map.project(sw);
        var neProject = map.project(ne);
        var features = map.queryRenderedFeatures([swProject,neProject], {
            layers:['polys']
        });

        toDissolve = blank();
        for (let i=0; i<features.length; i++) {
            
            if (features[i]['properties']['T_INDEX'] == toMatch) {
                toDissolve.features.push({
                    type:'Feature',
                    geometry:features[i].geometry,
                    properties:{'T_INDEX':toMatch}
                })
            }
        }

        fullGeom = turf.dissolve(toDissolve, {propertyName:'T_INDEX'});
        map.getSource('outlineSource').setData(fullGeom);
        page.mouseoverField = fullGeom;

    });
    map.on('mouseenter','polys',function(e) {
                    map.getCanvas().style.cursor = 'pointer';
                })
                map.on('mouseleave', 'polys', function(e) {
                     map.getCanvas().style.cursor = '';
                 })
                 map.on('mouseenter','outline',function(e) {
                    map.getCanvas().style.cursor = 'pointer';
                })
                map.on('mouseleave', 'outline', function(e) {
                     map.getCanvas().style.cursor = '';
                     map.getSource('outlineSource').setData(blank());
                 })
                
    map.on('sourcedata', sourceCallback);
    map.on('click', function(e) {
                
                var layers = map.queryRenderedFeatures(e.point);
                
                //only fire event for top layer
                // for (var i = 0; i<layers.length; i++) {
                //     if (layers[i]['layer']['id'] == 'polys') {
                //         user.fields.features.push(
                //             {
                //             type:'Feature',
                //             properties:{
                //                 T_INDEX:layers[i]['properties']['T_INDEX']
                //             },
                //             geometry:layers[i].geometry
                //             }
                //             )
                //         console.log(fields);
                //     }
                // }

                for (var i = 0; i<layers.length; i++) {
                     if (layers[i]['layer']['id'] == 'polys' && page.mouseoverField != null) {
                         var beforeSize = user.fields.features.length;
                         var filtered = user.fields.features.filter(function(d) {
                             return d.properties['T_INDEX'] != layers[i].properties['T_INDEX'];
                         })

                         var afterSize = filtered.length;
        
                         if (beforeSize != afterSize) {
                            user.fields.features = filtered;
                         }
                         else {
                            user.fields.features.push(page.mouseoverField.features[0]);
                         }  
                     }
                }

                // var features = map.queryRenderedFeatures({ layers: ['polys'] });
                
                // //console.log(features);
                // var lastAdded = user.fields.features[user.fields.features.length-1].properties['T_INDEX'];
                // toDissolve = blank();
                // for (let i=0; i<features.length; i++) {
                    
                //     if (features[i]['properties']['T_INDEX'] == lastAdded) {
                //         toDissolve.features.push({
                //             type:'Feature',
                //             geometry:features[i].geometry
                //         })
                //     }
                // }


                var fieldDivs = d3.select('#selectedFields').selectAll('div').data(user.fields.features);
                //fieldDivs.data(fields);
                fieldDivs.exit().remove();
                fieldDivs
                    .text(
                        function(d) {
                        return d.properties.T_INDEX;
                    }
                    );
                fieldDivs.enter().append('div')
                    .attr('class', 'fieldDiv')
                    .text(function(d) {
                        return d.properties.T_INDEX;
                    })
                var updated = blank();
                updated.features = user.fields.features;
                map.getSource('userFields').setData(updated);
            })
    //map.on('zoomend', function() {
    //    setColor();
        
         //if (features) {
         //var uniqueFeatures = getUniqueFeatures(features);
         //fields = uniqueFeatures;
         //console.log(uniqueFeatures);
        // // Populate features for the listing overlay.
        // renderListings(uniqueFeatures);
        
        // // Clear the input container
        // filterEl.value = '';
        
        // // Store the current features in sn `airports` variable to
        // // later use for filtering on `keyup`.
        // airports = uniqueFeatures;
        // }
    //);
    
})
</script>